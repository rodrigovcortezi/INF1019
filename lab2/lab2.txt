INF1019 - Lab 2
Nome: Rodrigo V. Cortezi
Matricula: 1511425

//
// Exercício 1
//

void exercicio1a() {
    int shm_id;
    char message[100];

    // Faz a leitura do teclado
    scanf("%[^\n]", message);

    shm_id = shmget(IPC_PRIVATE, sizeof(message), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(shm_id == -1) {
	printf("Shared memory allocation error.\n");
	exit(-1);
    }
    char *page = (char*) shmat(shm_id, NULL, 0);
    if(*page == -1) {
	printf("Shared memory attachement error.\n");
	exit(-1);
    }
    memcpy(page, message, sizeof(message));
    printf("shm_id: %d\n", shm_id);
}

Entrada:

Hello World!

Resultado:

shm_id: 1507341

No outro programa:

void exercicio1b() {
    const int shm_id = 1507341;
    char *message = (char*) shmat(shm_id, NULL, 0);
    if(*message == -1) {
	printf("Shared memory attachment error.\n");
	exit(-1);
    }

    printf("%s\n", message);
}

Resultado:

Hello World!

Análise e conclusão:

No primeiro programa criamos uma área de memória compartilhada que pode ser acessada pelo usuário para escrita e leitura. Salvamos a
mensagem do dia nessa área alocada e "printamos" o seu id. No segundo programa, utilizamos essa id para anexar o segmento já criado,
e então exibimos a mensagem do dia contida na memória compartilhada.

//
// Exercício 2
//

void exercicio2() {
    int i;
    int shm_id;
    int pid, status;
    int vetor[128];
    int *next_partition, *process_found;
    int result;
    const int partition_count = 8;
    const int partition_size = 128 / partition_count;
    
    // Inicializa o vetor com valores aleatórios
    srand(time(NULL));
    for(i = 0; i < 128; i++) {
	vetor[i] = 1 + rand() % 128;
    }

    // Aloca a memória compartilhada
    shm_id = shmget(IPC_PRIVATE, partition_count * sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(shm_id == -1) {
	printf("Shared memory allocation error.\n");
	exit(-1);
    }

    process_found = (int*) shmat(shm_id, NULL, 0);
    if(*process_found == -1) {
	printf("Shared memory attachment error.\n");
	exit(-1);
    }

    // Cria os processos filhos para cada divisão do vetor.
    for(i = 0; i < partition_count; i++) {
	pid = fork();
	if(pid == 0) {
	    // Child process
	    next_partition = vetor + (i * partition_size); // Obtem o endereço que aponta para o primeiro elemento da próxima parte do vetor.
	    process_found[i] = (i * partition_size) + get_biggest(next_partition, partition_size); // Obtem a posição de maior valor na divisão do vetor.
	    exit(0);
	} else if(pid < 0) {
	    // Fork error
	    printf("Fork error.\n");
	    exit(-1);
	}
    }

    // Processo pai aguarda os processos filhos terminarem
    while(wait(&status) > 0);

    // Verifica qual número dentre os encontrados é o maior
    result = process_found[0];
    for(i = 1; i < partition_count; i++) {
	if(vetor[process_found[i]] > vetor[result]) {
	    result = process_found[i];
	}
    }

    if(shmdt(process_found) == -1) {
	printf("Shared memory detachment erro.\n");
	exit(-1);
    }
    shmctl(shm_id, IPC_RMID, NULL);

    for(i = 0; i < 128; i++) {
	printf("%d - ", vetor[i]);
    }
    printf("\n");

    printf("result: %d\n", vetor[result]);
}

// Função auxiliar que procura a posição de maior valor em um vetor de tamanho n.
int get_biggest(int *array, int n) {
    int i;
    int biggest = 0;
    for(i = 1; i < n; i++) {
	if(array[i] > array[biggest]) {
	    biggest = i;
	}
    }

    return biggest;
}

Resultados:

23 - 83 - 119 - 111 - 16 - 89 - 8 - 106 - 46 - 71 - 78 - 2 - 97 - 109 - 115 - 77 - 107 - 124 - 90 - 20 - 27 - 117 - 83 - 81 - 118 - 13 - 125 - 48 - 30 - 99 - 40 - 100 - 86 - 56 - 89 - 97 - 54 - 33 - 116 - 28 - 87 - 3 - 60 - 94 - 64 - 50 - 58 - 45 - 115 - 114 - 23 - 70 - 97 - 26 - 17 - 20 - 84 - 12 - 105 - 107 - 76 - 46 - 54 - 79 - 54 - 110 - 105 - 58 - 117 - 53 - 38 - 121 - 88 - 37 - 42 - 41 - 28 - 48 - 24 - 97 - 46 - 28 - 109 - 19 - 28 - 46 - 87 - 86 - 4 - 95 - 37 - 92 - 74 - 54 - 62 - 93 - 111 - 98 - 117 - 45 - 102 - 41 - 12 - 12 - 124 - 119 - 103 - 4 - 69 - 124 - 50 - 28 - 58 - 49 - 10 - 107 - 127 - 56 - 23 - 98 - 62 - 36 - 116 - 48 - 60 - 51 - 65 - 56 -
result: 127

Análise e conclusão:

Primeiramente, o processo pai cria um vetor de 128 posições preenchido aleatoriamente. Depois, cria uma área de memória compartilhada que servirá para os outros processos
escreverem a posição que contém o maior valor em cada divisão do vetor. O processo pai cria um processo filho para cada divisão do vetor, e cada processo filho, então, busca
a posição que contém o maior valor nessa divisão do vetor, armazenando o resultado encontrado na memória compartilhada e termina. Quando todos os processos filhos acabam, o 
processo pai verifica qual é o maior valor dentre os encontrados pelos processos filhos e libera a memória compartilhada.
Isso permitiu fazer a seleção do maior valor no vetor com tempo otimizado, pois possibiliou o uso de mais de uma cpu.

