INF1019 - Lab 2
Nome: Rodrigo V. Cortezi
Matricula: 1511425

//
// Exercício 1
//

void exercicio1a() {
    int shm_id;
    char message[100];

    // Faz a leitura do teclado
    scanf("%[^\n]", message);

    shm_id = shmget(IPC_PRIVATE, sizeof(message), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(shm_id == -1) {
	printf("Shared memory allocation error.\n");
	exit(-1);
    }
    char *page = (char*) shmat(shm_id, NULL, 0);
    if(*page == -1) {
	printf("Shared memory attachement error.\n");
	exit(-1);
    }
    memcpy(page, message, sizeof(message));
    printf("shm_id: %d\n", shm_id);
}

Entrada:

Hello World!

Resultado:

shm_id: 1507341

No outro programa:

void exercicio1b() {
    const int shm_id = 1507341;
    char *message = (char*) shmat(shm_id, NULL, 0);
    if(*message == -1) {
	printf("Shared memory attachment error.\n");
	exit(-1);
    }

    printf("%s\n", message);
}

Resultado:

Hello World!

Análise e conclusão:

No primeiro programa criamos uma área de memória compartilhada que pode ser acessada pelo usuário para escrita e leitura. Salvamos a
mensagem do dia nessa área alocada e "printamos" o seu id. No segundo programa, utilizamos essa id para anexar o segmento já criado,
e então exibimos a mensagem do dia contida na memória compartilhada.

//
// Exercício 2
//

void exercicio2() {
    int i;
    int shm_id;
    int pid, status;
    int vetor[128];
    int *next_partition, *process_found;
    int result;
    const int partition_count = 8;
    const int partition_size = 128 / partition_count;
    
    // Inicializa o vetor com valores aleatórios
    srand(time(NULL));
    for(i = 0; i < 128; i++) {
	vetor[i] = 1 + rand() % 128;
    }

    // Aloca a memória compartilhada
    shm_id = shmget(IPC_PRIVATE, partition_count * sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    if(shm_id == -1) {
	printf("Shared memory allocation error.\n");
	exit(-1);
    }

    process_found = (int*) shmat(shm_id, NULL, 0);
    if(*process_found == -1) {
	printf("Shared memory attachment error.\n");
	exit(-1);
    }

    // Cria os processos filhos para cada divisão do vetor.
    for(i = 0; i < partition_count; i++) {
	pid = fork();
	if(pid == 0) {
	    // Child process
	    next_partition = vetor + (i * partition_size); // Obtem o endereço que aponta para o primeiro elemento da próxima parte do vetor.
	    process_found[i] = (i * partition_size) + get_biggest(next_partition, partition_size); // Obtem a posição de maior valor na divisão do vetor.
	    exit(0);
	} else if(pid < 0) {
	    // Fork error
	    printf("Fork error.\n");
	    exit(-1);
	}
    }

    // Processo pai aguarda os processos filhos terminarem
    while(wait(&status) > 0);

    // Verifica qual número dentre os encontrados é o maior
    result = process_found[0];
    for(i = 1; i < partition_count; i++) {
	if(vetor[process_found[i]] > vetor[result]) {
	    result = process_found[i];
	}
    }

    if(shmdt(process_found) == -1) {
	printf("Shared memory detachment erro.\n");
	exit(-1);
    }
    shmctl(shm_id, IPC_RMID, NULL);

    for(i = 0; i < 128; i++) {
	printf("%d - ", vetor[i]);
    }
    printf("\n");

    printf("result: %d\n", vetor[result]);
}

// Função auxiliar que procura a posição de maior valor em um vetor de tamanho n.
int get_biggest(int *array, int n) {
    int i;
    int biggest = 0;
    for(i = 1; i < n; i++) {
	if(array[i] > array[biggest]) {
	    biggest = i;
	}
    }

    return biggest;
}

Resultado:

23 - 83 - 119 - 111 - 16 - 89 - 8 - 106 - 46 - 71 - 78 - 2 - 97 - 109 - 115 - 77 - 107 - 124 - 90 - 20 - 27 - 117 - 83 - 81 - 118 - 13 - 125 - 48 - 30 - 99 - 40 - 100 - 86 - 56 - 89 - 97 - 54 - 33 - 116 - 28 - 87 - 3 - 60 - 94 - 64 - 50 - 58 - 45 - 115 - 114 - 23 - 70 - 97 - 26 - 17 - 20 - 84 - 12 - 105 - 107 - 76 - 46 - 54 - 79 - 54 - 110 - 105 - 58 - 117 - 53 - 38 - 121 - 88 - 37 - 42 - 41 - 28 - 48 - 24 - 97 - 46 - 28 - 109 - 19 - 28 - 46 - 87 - 86 - 4 - 95 - 37 - 92 - 74 - 54 - 62 - 93 - 111 - 98 - 117 - 45 - 102 - 41 - 12 - 12 - 124 - 119 - 103 - 4 - 69 - 124 - 50 - 28 - 58 - 49 - 10 - 107 - 127 - 56 - 23 - 98 - 62 - 36 - 116 - 48 - 60 - 51 - 65 - 56 -
result: 127

Análise e conclusão:

Primeiramente, o processo pai cria um vetor de 128 posições preenchido aleatoriamente. Depois, cria uma área de memória compartilhada que servirá para os outros processos
escreverem a posição que contém o maior valor em cada divisão do vetor. O processo pai cria um processo filho para cada divisão do vetor, e cada processo filho, então, busca
a posição que contém o maior valor nessa divisão do vetor, armazenando o resultado encontrado na memória compartilhada e termina. Quando todos os processos filhos acabam, o 
processo pai verifica qual é o maior valor dentre os encontrados pelos processos filhos e libera a memória compartilhada.
Isso permitiu fazer a seleção do maior valor no vetor com tempo otimizado, pois possibiliou o uso de mais de uma cpu.

//
// Exercício 3
//

void exercicio3() {
    const int dimension = 4;
    int i, j;
    int matriz[dimension][dimension];
    int pid, status;
    int v_shm_id[dimension];
    int *linha;
    int *transposta[dimension];
    for(i = 0; i < dimension; i++) {
	for(j = 0; j < dimension; j++) {
	    scanf("%d", &matriz[i][j]);
	}
    }

    printf("\nmatriz original: \n");
    for(i = 0; i < dimension; i++) {
	for(j = 0; j < dimension; j++) {
	    printf("%d ", matriz[i][j]);
	}
	printf("\n");
    }

    for(i = 0; i < dimension; i++) {
	v_shm_id[i] = shmget(IPC_PRIVATE, dimension * sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
	if(v_shm_id[i] == -1) {
	    printf("Shared memory allocation error.\n");
	    exit(-1);
	}
	transposta[i] = (int *) shmat(v_shm_id[i], NULL, 0);
    }

    for(i = 0; i < dimension; i++) {
	pid = fork();
	if(pid == 0) {
	    // Child process
	    linha = matriz[i];
	    for(j = 0; j < dimension; j++) {
		transposta[j][i] = linha[j];
	    }
	    exit(0);
	} else if(pid < 0) {
	    // Fork error
	    printf("Fork error.\n");
	    exit(-1);
	}
    }

    while(wait(&status) > 0);
    
    printf("\nmatriz transposta: \n");
    for(i = 0; i < dimension; i++) {
	for(j = 0; j < dimension; j++) {
	    printf("%d ", transposta[i][j]);
	}
	printf("\n");
    }

    for(i = 0; i < dimension; i++) {
	if(shmdt(transposta[i]) == -1) {
	    printf("Shared memory detatchment error.\n");
	    exit(-1);
	}
	shmctl(v_shm_id[i], IPC_RMID, NULL);
    }
}

Resultado:

Entrada:
1 2 3 4
5 5 5 5
3 2 2 1
1 1 1 1

matriz original: 
1 2 3 4 
5 5 5 5 
3 2 2 1 
1 1 1 1 

matriz transposta: 
1 5 3 1 
2 5 2 1 
3 5 2 1 
4 5 1 1 

Análise e conclusão:

O processo pai cria a matriz original lendo os elementos através de entradas no teclado. Não me fez sentido alocar essa matriz em memória compartilhada,
já que todos os outros processos iriam ter uma cópia da mesma. Depois disso, o processo pai cria um matriz na memória compartilhada para conter a matriz
transposta. Para fazer isso, criei um vetor de ponteiros onde cada ponteiro aponta para um segmento de memória compartilhada diferente. 
Os processos filhos são criados e cada um deles acessa a matriz original, pegando uma linha e colocando na respectiva coluna da matriz transposta (essa 
em memória compartilhada). Depois que todos os filhos terminam, o processo pai "printa" a matriz transposta e libera a memória compartilhada alocada pela mesma.

